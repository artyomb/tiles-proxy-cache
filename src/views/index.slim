.section
  .section-title Service Statistics
  .stats-grid
    .stat-box
      .stat-number = @total_sources
      .stat-desc Available sources
    .stat-box
      .stat-number.loading id="total-tiles" â³
      .stat-desc Total cached tiles
    .stat-box
      .stat-number.loading id="total-misses" â³
      .stat-desc Cache misses
    .stat-box
      .stat-number.loading id="total-cache-size" â³
      .stat-desc Cache size
    .stat-box
      .stat-number = "#{(@uptime / 3600).to_i}h #{((@uptime % 3600) / 60).to_i}m"
      .stat-desc Uptime

.section
  .section-title 
    | Application Configuration
    .header-buttons
      a.btn href="#" onclick="toggleGlobalConfig()" ðŸ“‹ View Config
      a.btn href=url_for("/db") ðŸ—„ï¸ Database Viewer
  
  .global-config.hidden id="global-config"
    .config-yaml
      pre = @original_config.to_yaml

.section
  .section-title Available Sources
  - ROUTES.each do |name, route|
    .source-card
      .source-header
        .source-name = name
        .source-actions
          a.btn.style-btn href=url_for(route[:path].gsub(/\/:[zxy]/, '')) ðŸ“‹ JSON Style
          - if route.dig(:gap_filling, :enabled)
            .mode-selector-wrapper
              span.mode-selector-icon â–¼
              select.mode-selector id="mode-select-#{name}"
                option value="incremental" Incremental
                option value="full" Full Rebuild
            a.btn.reconstruct-btn href="#" onclick="startReconstructor('#{name}', event)" id="reconstruct-btn-#{name}" âš™ï¸ Reconstruct
          - if route.dig(:autoscan, :enabled)
            a.btn.reset-autoscan-btn href="#" onclick="resetAutoscan('#{name}', event)" id="reset-autoscan-btn-#{name}" ðŸ”„ Reset Scan
          a.btn.map-btn href=url_for("/map?source=#{name}") ðŸŒ Map preview
          a.btn.debug-btn href=url_for("/map?source=#{name}&debug=true") Debug Map
      
      .source-main-info
        .info-grid
          .info-header
            .info-item
              .info-label Target URL
              .info-value = route[:target]
            .info-item
              .info-label Path
              .info-value = route[:path]
          .coverage-chart
            svg id="chart-#{name}" data-source="#{name}"
          .info-footer
            .info-item
              .info-label Zoom Range
              .info-value = "#{route[:minzoom] || 1} - #{route[:maxzoom] || 20}"
            .info-item
              .info-label Tile Size
              .info-value = "#{route[:tile_size]}px"
            .info-item
              .info-label Cached Tiles
              .info-value.loading id="tiles-#{name}" â³
            .info-item
              .info-label Cache Misses
              .info-value.loading id="misses-#{name}" â³
            .info-item
              .info-label Cache Size
              .info-value.loading id="size-#{name}" â³
            .info-item
              .info-label Coverage
              .info-value.loading id="coverage-#{name}" â³
            .info-item
              .info-label Autoscan
              .info-value = route.dig(:autoscan, :enabled) ? 'Enabled' : 'Disabled'
            .info-item
              .info-label Scan Zoom
              .info-value = route.dig(:autoscan, :max_scan_zoom) || 'N/A'

javascript:
  const BASE_PATH = '#{base_path}';
  
  const setReconstructControls = (src, running) => {
    const btn = document.getElementById(`reconstruct-btn-${src}`);
    const selector = document.getElementById(`mode-select-${src}`);
    if (btn) {
      btn.disabled = running;
      btn.textContent = running ? 'â³ Running...' : 'âš™ï¸ Reconstruct';
    }
    if (selector) {
      selector.disabled = running;
    }
  };
  
  const pollStatus = (src, onComplete) => {
    const iv = setInterval(() => 
      fetch(`${BASE_PATH}/api/reconstructor/${src}/status`)
        .then(r => r.json())
        .then(d => {
          if (!d.running) {
            clearInterval(iv);
            setReconstructControls(src, false);
            if (onComplete) onComplete();
          }
        })
        .catch(() => clearInterval(iv)),
      5000
    );
  };
  
  function startReconstructor(src, e) {
    e.preventDefault();
    const modeSelect = document.getElementById(`mode-select-${src}`);
    const mode = modeSelect ? modeSelect.value : 'incremental';
    const modeLabel = mode === 'full' ? 'Full Rebuild' : 'Incremental';
    showModal('Confirm Action', `Start ${modeLabel.toLowerCase()} tile reconstruction for ${src}?`, () => {
      setReconstructControls(src, true);
      fetch(`${BASE_PATH}/api/reconstructor/${src}/start?mode=${mode}`, { 
        method: 'POST'
      })
        .then(r => r.json())
        .then(data => {
          if (data.success) {
            pollStatus(src, () => showToast(`Reconstruction completed for ${src}`));
          } else {
            showToast(data.error || 'Unknown error', true);
            setReconstructControls(src, false);
          }
        })
        .catch(err => { showToast(err.message, true); setReconstructControls(src, false); });
    });
  }
  
  const resetAutoscan = (src, e) => {
    e.preventDefault();
    
    fetch(`${BASE_PATH}/api/autoscan/${src}/status`)
      .then(r => r.json())
      .then(statusData => {
        showAutoscanResetModal(src, statusData.zoom_range);
      })
      .catch(err => showToast('Failed to fetch autoscan status: ' + err.message, true));
  };
  
  const showAutoscanResetModal = (src, zoomRange) => {
    const modalOverlay = document.getElementById('modal-overlay');
    
    const zoomOptions = ['<option value="all">All Zoom Levels</option>'];
    for (let z = zoomRange.min; z <= zoomRange.max; z++) {
      zoomOptions.push(`<option value="${z}">Zoom ${z}</option>`);
    }
    
    const zoomSelectHtml = `
      <div style="margin: 12px 0;">
        <label style="color: #808080; font-size: 12px; display: block; margin-bottom: 6px;">Select Zoom Level:</label>
        <select id="autoscan-zoom-select" style="width: 100%; padding: 6px; background: #2b2b2b; color: #a9b7c6; border: 1px solid #555; border-radius: 3px; font-size: 12px;">
          ${zoomOptions.join('')}
        </select>
      </div>
    `;
    
    document.getElementById('modal-title').textContent = 'Reset Autoscan Progress';
    document.getElementById('modal-message').innerHTML = 
      `Reset autoscan progress and clear errors for <strong>${src}</strong>?${zoomSelectHtml}`;
    
    modalCallback = () => {
      const zoomLevel = document.getElementById('autoscan-zoom-select').value;
      performAutoscanReset(src, zoomLevel);
    };
    
    modalOverlay.classList.add('show');
  };
  
  const performAutoscanReset = (src, zoomLevel) => {
    const btn = document.getElementById(`reset-autoscan-btn-${src}`);
    const originalText = btn.textContent;
    btn.disabled = true;
    btn.textContent = 'â³ Resetting...';
    
    fetch(`${BASE_PATH}/api/autoscan/${src}/reset`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({ zoom_level: zoomLevel })
    })
      .then(r => r.json())
      .then(data => {
        if (data.success) {
          const zoomInfo = zoomLevel === 'all' ? 'all zoom levels' : `zoom ${zoomLevel}`;
          showToast(`Autoscan reset completed for ${zoomInfo} (${data.zoom_levels.length} levels)`);
          btn.textContent = 'âœ“ Reset';
          setTimeout(() => {
          btn.textContent = originalText;
          btn.disabled = false;
          location.reload();
          }, 2000);
        } else {
          throw new Error(data.error || 'Unknown error');
        }
      })
      .catch(err => {
        showToast('Reset failed: ' + err.message, true);
        btn.textContent = originalText;
        btn.disabled = false;
      });
  };
  
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      fetch(`${BASE_PATH}/api/stats`)
        .then(r => r.json())
        .then(data => {
          ['total-tiles', 'total-misses', 'total-cache-size'].forEach((id, i) => {
            const el = document.getElementById(id);
            el.textContent = i === 2 ? (data.totals.cache_size / 1024 / 1024).toFixed(2) + ' MB' : data.totals[id.replace('total-', '')];
            el.classList.remove('loading');
          });
          
          Object.keys(data.route_stats).forEach(src => {
            const s = data.route_stats[src];
            ['tiles', 'misses', 'size', 'coverage'].forEach(k => {
              const el = document.getElementById(`${k}-${src}`);
              el.textContent = k === 'size' ? (s.cache_size / 1024 / 1024).toFixed(2) + ' MB' : 
                               k === 'coverage' ? s.coverage_percentage + '%' : s[k + '_count'];
              el.classList.remove('loading');
            });
            
            const chart = document.getElementById(`chart-${src}`);
            if (chart && s.coverage_data) createCoverageChart(`chart-${src}`, s.coverage_data);
          });
          
          document.querySelectorAll('[id^="reconstruct-btn-"]').forEach(btn => {
            const src = btn.id.replace('reconstruct-btn-', '');
            fetch(`${BASE_PATH}/api/reconstructor/${src}/status`)
              .then(r => r.json())
              .then(d => { if (d.running) { setReconstructControls(src, true); pollStatus(src); } })
              .catch(() => {});
          });
        })
        .catch(err => {
          console.error('Error loading stats:', err);
          document.querySelectorAll('.loading').forEach(el => {
            el.textContent = 'Error';
            el.classList.remove('loading');
            el.classList.add('error');
          });
        });
    }, 0);
  });