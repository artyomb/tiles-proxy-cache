.section
  .section-title Service Statistics
  .stats-grid
    .stat-box
      .stat-number = @total_sources
      .stat-desc Available sources
    .stat-box
      .stat-number.loading id="total-tiles" â³
      .stat-desc Total cached tiles
    .stat-box
      .stat-number.loading id="total-misses" â³
      .stat-desc Cache misses
    .stat-box
      .stat-number.loading id="total-cache-size" â³
      .stat-desc Cache size
    .stat-box
      .stat-number = "#{(@uptime / 3600).to_i}h #{((@uptime % 3600) / 60).to_i}m"
      .stat-desc Uptime

.section
  .section-title 
    | Application Configuration
    .header-buttons
      a.btn href="#" onclick="toggleGlobalConfig()" ðŸ“‹ View Config
      a.btn href="/db" ðŸ—„ï¸ Database Viewer
  
  .global-config.hidden id="global-config"
    .config-yaml
      pre = @original_config.to_yaml

.section
  .section-title Available Sources
  - ROUTES.each do |name, route|
    .source-card
      .source-header
        .source-name = name
        .source-actions
          a.btn.style-btn href=route[:path].gsub(/\/:[zxy]/, '') ðŸ“‹ JSON Style
          - if route[:gap_filling]
            a.btn.reconstruct-btn href="#" onclick="startReconstructor('#{name}', event)" id="reconstruct-btn-#{name}" âš™ï¸ Reconstruct
          a.btn.map-btn href="/map?source=#{name}" ðŸŒ Map preview
          a.btn.debug-btn href="/map?source=#{name}&debug=true" Debug Map
      
      .source-main-info
        .info-grid
          .info-header
            .info-item
              .info-label Target URL
              .info-value = route[:target]
            .info-item
              .info-label Path
              .info-value = route[:path]
          .coverage-chart
            svg id="chart-#{name}" data-source="#{name}"
          .info-footer
            .info-item
              .info-label Zoom Range
              .info-value = "#{route[:minzoom] || 1} - #{route[:maxzoom] || 20}"
            .info-item
              .info-label Tile Size
              .info-value = "#{route[:tile_size]}px"
            .info-item
              .info-label Cached Tiles
              .info-value.loading id="tiles-#{name}" â³
            .info-item
              .info-label Cache Misses
              .info-value.loading id="misses-#{name}" â³
            .info-item
              .info-label Cache Size
              .info-value.loading id="size-#{name}" â³
            .info-item
              .info-label Coverage
              .info-value.loading id="coverage-#{name}" â³
            .info-item
              .info-label Autoscan
              .info-value = route.dig(:autoscan, :enabled) ? 'Enabled' : 'Disabled'
            .info-item
              .info-label Scan Zoom
              .info-value = route.dig(:autoscan, :max_scan_zoom) || 'N/A'

javascript:
  const setBtn = (btn, running) => {
    btn.disabled = running;
    btn.textContent = running ? 'â³ Running...' : 'âš™ï¸ Reconstruct';
  };
  
  const pollStatus = (src, btn, onComplete) => {
    const iv = setInterval(() => 
      fetch(`/api/reconstructor/${src}/status`)
        .then(r => r.json())
        .then(d => {
          if (!d.running) {
            clearInterval(iv);
            setBtn(btn, false);
            if (onComplete) onComplete();
          }
        })
        .catch(() => clearInterval(iv)),
      5000
    );
  };
  
  function startReconstructor(src, e) {
    e.preventDefault();
    const btn = document.getElementById(`reconstruct-btn-${src}`);
    showModal('Confirm Action', `Start tile reconstruction for ${src}?`, () => {
      setBtn(btn, true);
      fetch(`/api/reconstructor/${src}/start`, { method: 'POST' })
        .then(r => r.json())
        .then(data => {
          if (data.success) {
            pollStatus(src, btn, () => showToast(`Reconstruction completed for ${src}`));
          } else {
            showToast(data.error || 'Unknown error', true);
            setBtn(btn, false);
          }
        })
        .catch(err => { showToast(err.message, true); setBtn(btn, false); });
    });
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      fetch('/api/stats')
        .then(r => r.json())
        .then(data => {
          ['total-tiles', 'total-misses', 'total-cache-size'].forEach((id, i) => {
            const el = document.getElementById(id);
            el.textContent = i === 2 ? (data.totals.cache_size / 1024 / 1024).toFixed(2) + ' MB' : data.totals[id.replace('total-', '')];
            el.classList.remove('loading');
          });
          
          Object.keys(data.route_stats).forEach(src => {
            const s = data.route_stats[src];
            ['tiles', 'misses', 'size', 'coverage'].forEach(k => {
              const el = document.getElementById(`${k}-${src}`);
              el.textContent = k === 'size' ? (s.cache_size / 1024 / 1024).toFixed(2) + ' MB' : 
                               k === 'coverage' ? s.coverage_percentage + '%' : s[k + '_count'];
              el.classList.remove('loading');
            });
            
            const chart = document.getElementById(`chart-${src}`);
            if (chart && s.coverage_data) createCoverageChart(`chart-${src}`, s.coverage_data);
          });
          
          document.querySelectorAll('[id^="reconstruct-btn-"]').forEach(btn => {
            const src = btn.id.replace('reconstruct-btn-', '');
            fetch(`/api/reconstructor/${src}/status`)
              .then(r => r.json())
              .then(d => { if (d.running) { setBtn(btn, true); pollStatus(src, btn); } })
              .catch(() => {});
          });
        })
        .catch(err => {
          console.error('Error loading stats:', err);
          document.querySelectorAll('.loading').forEach(el => {
            el.textContent = 'Error';
            el.classList.remove('loading');
            el.classList.add('error');
          });
        });
    }, 0);
  });