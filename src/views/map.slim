ruby:
  style_name = params[:style]
  external_style_url = params[:style_url]
  style_url = external_style_url || (style_name ? "#{request.base_url}/styles/#{style_name}" : @style_url)

#loading-indicator
  .loading-progress
    .loading-text Loading map...
    .progress-bar
      .progress-fill

- if style_name || external_style_url || @style_url
  .layer-controls
    .mode-switcher
      button.mode-button.active id="mode-filters" onclick="switchMode(this, 'filters')" Filters
      button.mode-button id="mode-layers" onclick="switchMode(this, 'layers')" Layers
    button.control-button onclick="toggleHoverMode()" id="hover-mode-btn" Hover Mode

    #filters-panel.control-panel.active
      .control-panel-header
        button.control-button onclick="toggleAllFilters()" Toggle All Filters
        button.control-button onclick="toggleBasemap()" Show/Hide Basemap
      .control-panel-content
        #filter-buttons

    #layers-panel.control-panel
      .control-panel-header
        button.control-button onclick="toggleAllLayers()" Toggle All Layers
        button.control-button onclick="toggleBasemap()" Show/Hide Basemap
      .control-panel-content
        #layer-buttons

#map-container
  #map.map-layer data-style-url="#{style_url}"

  #performance-panel.performance-overlay
    button.performance-toggle onclick="togglePerformancePanel()" ×
    .performance-content
      .metric-row
        .metric
          span.metric-label FPS:
          span.metric-value#fps-value 0
        .metric
          span.metric-label Frame:
          span.metric-value#frame-time-value 0ms
        .metric
          span.metric-label Memory:
          span.metric-value#memory-usage-value 0MB
        .metric
          span.metric-label Zoom:
          span.metric-value#zoom-level-value 0
      .metric-row
        .metric
          span.metric-label Tiles:
          span.metric-value#tiles-loaded-value 0
        .metric
          span.metric-label Loading:
          span.metric-value#tiles-loading-value 0
        .metric
          span.metric-label Layers:
          span.metric-value#layers-active-value 0
      .metric-row#terrain-row style="display: none;"
        .metric
          span.metric-label Terrain:
          span.metric-value#terrain-status-value -

javascript:
    const mapEl = document.getElementById('map');
    const style_url = mapEl?.dataset?.styleUrl || null;
    let showBasemapFilters = true, showBasemapLayers = true, currentMode = 'filters';
    let hoverMode = 'click';
    let layerStates = {};
    let map = null;
    let styleLoaded = false, resourcesLoaded = 0, totalResources = 0;
    let tilesLoaded = 0, tilesTotal = 0;
    let currentStyle = null;
    const layerIdToDomId = {};
    let filters = null;

    const toDomId = (prefix, id) => `${prefix}-${String(id).replace(/[^a-zA-Z0-9_-]/g, '_')}`;


    const showLoading = () => document.getElementById('loading-indicator').style.display = 'block';
    const hideLoading = () => document.getElementById('loading-indicator').style.display = 'none';

    const updateLoadingProgress = () => {
        let progress = 0;
        let loadingText = 'Loading map...';

        if (totalResources > 0) {
            const resourceProgress = Math.round((resourcesLoaded / totalResources) * 50);
            progress = resourceProgress;
            loadingText = `Loading resources... ${resourceProgress * 2}%`;
        }

        if (map?.getStyle()?.sources) {
            const sources = Object.keys(map.getStyle().sources);
            if (sources.length > 0) {
                const tileProgress = Math.round((tilesLoaded || 0) / sources.length * 50);
                progress = Math.min(100, (totalResources > 0 ? 50 : 0) + tileProgress);
                loadingText = `Loading tiles... ${progress}%`;
            }
        }

        document.querySelector('.loading-text').textContent = loadingText;
        document.querySelector('.progress-fill').style.width = `${progress}%`;
    };

    const switchMode = (arg1, arg2) => {
        const isStringArg = typeof arg1 === 'string';
        const mode = isStringArg ? arg1 : arg2;
        const target = isStringArg ? null : (arg1?.currentTarget || arg1);
        currentMode = mode;

        document.querySelectorAll('.mode-button').forEach(btn => btn.classList.remove('active'));
        (target || document.getElementById(`mode-${mode}`))?.classList.add('active');

        document.getElementById('filters-panel').classList.toggle('active', mode === 'filters');
        document.getElementById('layers-panel').classList.toggle('active', mode === 'layers');

        mode === 'filters' ? filters?.setMode(mode) : applyLayerMode();
        applyBasemapVisibility();
        updateBasemapButton();
    };


    const applyLayerMode = () => {
        Object.keys(layerStates).forEach(layerId => {
            if (map.getLayer(layerId)) {
                map.setLayoutProperty(layerId, 'visibility', layerStates[layerId] ? 'visible' : 'none');
            }
        });
    };

    const applyBasemapVisibility = () => {
        const isVisible = currentMode === 'filters' ? showBasemapFilters : showBasemapLayers;
        map?.getLayer?.('preview-basemap-layer') && map.setLayoutProperty('preview-basemap-layer', 'visibility', isVisible ? 'visible' : 'none');
    };

    const checkStyleResources = (style) => {
        totalResources = 0;
        resourcesLoaded = 0;
        const promises = [];

        if (style.glyphs) {
            totalResources += 1;
            promises.push(Promise.resolve().then(() => {
                resourcesLoaded++;
                updateLoadingProgress();
            }));
        }

        if (totalResources > 0) {
            showLoading();
            updateLoadingProgress();
            Promise.all(promises).then(() => {
                styleLoaded = true;
            });
        }
    };

    const createMap = (container, style) => new maplibregl.Map({
        container,
        style,
        center: [35.15, 47.41],
        zoom: 2,
        attributionControl: false,
        validateStyle: false,
        antialias: true
    });

    const addBasemapToStyle = (originalStyle) => {
        const modifiedStyle = JSON.parse(JSON.stringify(originalStyle));

        modifiedStyle.sources = modifiedStyle.sources || {};
        modifiedStyle.sources['preview-basemap'] = {
            type: 'raster',
            tiles: [
                'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
                'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            tileSize: 256,
            maxzoom: 19,
            attribution: '© OpenStreetMap contributors'
        };

        modifiedStyle.layers = modifiedStyle.layers || [];
        modifiedStyle.layers.unshift({
            id: 'preview-basemap-layer',
            type: 'raster',
            source: 'preview-basemap',
            layout: {visibility: 'visible'},
            paint: {'raster-opacity': 0.8, 'raster-fade-duration': 300}
        });

        return modifiedStyle;
    };

    const popupFeature = (features, e, popup) => {
        const tt = (tooltip, feat) => tooltip?.replace(/\{([^}]+)\}/g, (match, prop) => {
            let value = feat;
            for (const p of prop.split('.')) {
                value = value?.[p];
            }
            return typeof value === 'object' ? JSON.stringify(value, null, 2) : (value || '');
        });

        const tooltips = features.map((feat) =>
            tt(feat.layer.metadata?.tooltip, feat) ||
            tt(`<pre>"id": {id},\n"source": {source},\n"source-layer": {sourceLayer},\n"properties": {properties}</pre>`, feat)
        );
        popup.setLngLat(e.lngLat).setHTML(tooltips.join('<br>')).addTo(map);
    };

    const initializeMap = () => {
        showLoading();
        const emptyStyle = {version: 8, sources: {}, layers: []};

        style_url
            ? fetch(style_url)
                .then(response => response.json())
                .then(originalStyle => createMapWithStyle(addBasemapToStyle(originalStyle)))
                .catch(error => {
                    console.error('Style loading error:', error);
                    createMapWithStyle(addBasemapToStyle(emptyStyle));
                })
            : createMapWithStyle(addBasemapToStyle(emptyStyle));
    };

    const createMapWithStyle = (style) => {
        map = createMap('map', style);
        setupMapEvents();
    };

    const setupMapEvents = () => {
        map.addControl(new maplibregl.NavigationControl());
        map.on('error', (e) => console.error('[MapLibre ERROR]', e?.error || e));

        map.on('style.load', () => {
            currentStyle = map.getStyle();
            currentStyle && initializeFiltersAndLayers();
            map.once('idle', onStyleReady);
            setupMapInteractions();
            setupPerformanceMonitoring();
        });
    };

    const initializeFiltersAndLayers = () => {
        try {
            checkStyleResources(currentStyle);
            filters = new Filters({
                map,
                container: '#filter-buttons',
                element_template: (title) => `<div class="element">${title}</div>`,
                group_template: (title) => `<div class="group">${title}</div>`
            });
            filters.init();
            createLayerButtons();
        } catch (e) {
            console.warn('Filter initialization failed:', e);
        }
    };

    const onStyleReady = () => {
        const hasTerrain = currentStyle?.terrain;
        const projectionType = hasTerrain ? 'mercator' : 'globe';

        try {
            map.setProjection({type: projectionType});
        } catch (e) {
            console.warn('Projection setting failed:', e);
        }

        try {
            map.addControl(new maplibregl.GlobeControl(), 'top-right');
        } catch (e) {
            console.warn('GlobeControl failed:', e);
        }

        updateTerrainIndicator();
    };

    const setupMapInteractions = () => {
        const popup = new maplibregl.Popup({closeButton: false, closeOnClick: false});

        map.on('click', function (e) {
            const features = this.queryRenderedFeatures(e.point);
            features.length > 0 && hoverMode === 'click' && popupFeature(features, e, popup);
            features.length > 0 && console.log('Clicked feature:', features[0]);
        });

        let timeout, point;
        map.on('mousemove', (e) => {
            if (hoverMode !== 'hover') {
                map.getCanvas().style.cursor = '';
                popup.remove();
                return;
            }

            clearTimeout(timeout);
            const features = map.queryRenderedFeatures(e.point);
            const hasFeatures = features.length > 0;

            map.getCanvas().style.cursor = hasFeatures ? 'crosshair' : '';
            hasFeatures ? timeout = setTimeout(() => popupFeature(features, e, popup), 100) : popup.remove();
            point?.equals(e.point) || popup.remove();
            point = e.point.clone();
        });

        map.on('sourcedata', (e) => {
            e.sourceId && e.isSourceLoaded && (tilesLoaded++,
            tilesTotal === 0 && (tilesTotal = Object.keys(map.getStyle().sources).length),
                updateLoadingProgress());
        });

        map.on('idle', () => {
            const allLoaded = (totalResources === 0 || styleLoaded) && (tilesTotal === 0 || tilesLoaded >= tilesTotal);
            allLoaded && hideLoading();
        });

        setTimeout(hideLoading, 10000);
    };

    const setupPerformanceMonitoring = () => {
        [startPerformanceMonitoring, () => requestAnimationFrame(countFrame),
            updateHoverModeButton, updateBasemapButton].forEach(fn => fn());
    };

    const toggleBasemap = () => {
        currentMode === 'filters' ? showBasemapFilters = !showBasemapFilters : showBasemapLayers = !showBasemapLayers;
        applyBasemapVisibility();
        updateBasemapButton();
    };

    const updateBasemapButton = () => {
        const isVisible = currentMode === 'filters' ? showBasemapFilters : showBasemapLayers;
        document.querySelectorAll('button[onclick="toggleBasemap()"]').forEach(btn => {
            btn.textContent = isVisible ? 'Hide Basemap' : 'Show Basemap';
            btn.className = `control-button ${isVisible ? 'active' : 'inactive'}`;
        });
    };

    const updateTerrainIndicator = () => {
        const terrainRow = document.getElementById('terrain-row');
        const terrainElement = document.getElementById('terrain-status-value');
        if (!terrainRow || !terrainElement) return;

        const hasTerrain = currentStyle?.terrain;
        if (hasTerrain) {
            terrainRow.style.display = 'flex';
            terrainElement.textContent = 'is detected';
            terrainElement.className = 'metric-value success';
        } else {
            terrainRow.style.display = 'none';
        }
    };


    const toggleHoverMode = () => {
        hoverMode = hoverMode === 'hover' ? 'click' : 'hover';
        updateHoverModeButton();
    };

    const updateHoverModeButton = () => {
        const btn = document.getElementById('hover-mode-btn');
        if (!btn) return;

        const isHoverMode = hoverMode === 'hover';
        btn.textContent = isHoverMode ? 'Click Mode' : 'Hover Mode';
        btn.className = `control-button ${isHoverMode ? 'active' : ''}`;
    };

    const toggleAllLayers = () => {
        if (currentMode !== 'layers') return;
        const allVisible = Object.values(layerStates).every(state => state);
        const newState = !allVisible;

        Object.keys(layerStates).forEach(layerId => {
            layerStates[layerId] = newState;
            if (map.getLayer(layerId)) {
                map.setLayoutProperty(layerId, 'visibility', newState ? 'visible' : 'none');
            }
        });

        if (map.getLayer('preview-basemap-layer')) {
            showBasemapLayers = newState;
        }

        updateLayerButtons();
        updateBasemapButton();
    };

    const toggleLayer = (layerId) => {
        if (currentMode !== 'layers') return;
        layerStates[layerId] = !layerStates[layerId];

        if (map.getLayer(layerId)) {
            map.setLayoutProperty(layerId, 'visibility', layerStates[layerId] ? 'visible' : 'none');
        }

        if (layerId === 'preview-basemap-layer') {
            showBasemapLayers = layerStates[layerId];
            updateBasemapButton();
        }

        updateLayerButtons();
    };

    const updateLayerButtons = () => {
        Object.keys(layerStates).forEach(layerId => {
            const btnId = layerIdToDomId[layerId] || toDomId('layer', layerId);
            const button = document.getElementById(btnId);
            if (button) {
                button.className = `control-button ${layerStates[layerId] ? 'active' : 'inactive'}`;
            }
        });
    };


    const createLayerButtons = () => {
        if (!currentStyle?.layers) return;

        const layerButtonsContainer = document.getElementById('layer-buttons');
        if (!layerButtonsContainer) return;

        currentStyle.layers.forEach(layer => {
            const button = document.createElement('button');
            const buttonId = toDomId('layer', layer.id);
            button.id = buttonId;
            button.className = 'control-button active';
            button.textContent = layer.id;
            button.onclick = () => toggleLayer(layer.id);
            layerButtonsContainer.appendChild(button);
            layerStates[layer.id] = true;
            layerIdToDomId[layer.id] = buttonId;
        });
    };


    let fpsCounter = 0, lastFpsTime = 0, frameCount = 0;
    let performanceMonitor = null;
    let performancePanelVisible = true;

    const togglePerformancePanel = () => {
        const panel = document.getElementById('performance-panel');
        performancePanelVisible = !performancePanelVisible;
        panel.style.display = performancePanelVisible ? 'block' : 'none';
    };

    const startPerformanceMonitoring = () => {
        if (performanceMonitor) return;
        performanceMonitor = setInterval(updatePerformanceMetrics, 1000);
    };

    const stopPerformanceMonitoring = () => {
        if (performanceMonitor) {
            clearInterval(performanceMonitor);
            performanceMonitor = null;
        }
    };

    const updatePerformanceMetrics = () => {
        if (!map) return;

        const now = performance.now();
        if (lastFpsTime === 0) {
            lastFpsTime = now;
            frameCount = 0;
        }

        frameCount++;
        if (now - lastFpsTime >= 1000) {
            const fps = Math.round((frameCount * 1000) / (now - lastFpsTime));
            const fpsElement = document.getElementById('fps-value');
            fpsElement.textContent = fps;
            fpsElement.className = `metric-value ${fps < 30 ? 'error' : fps < 50 ? 'warning' : 'success'}`;

            const frameTime = Math.round(1000 / fps);
            const frameElement = document.getElementById('frame-time-value');
            frameElement.textContent = `${frameTime}ms`;
            frameElement.className = `metric-value ${frameTime > 33 ? 'error' : frameTime > 20 ? 'warning' : 'success'}`;

            lastFpsTime = now;
            frameCount = 0;
        }

        try {
            const sourcesCount = map.getStyle()?.sources ? Object.keys(map.getStyle().sources).length : 0;
            document.getElementById('tiles-loaded-value').textContent = sourcesCount;

            const loadingTiles = map.isStyleLoaded() ? 0 : 1;
            document.getElementById('tiles-loading-value').textContent = loadingTiles;
        } catch (e) {
            console.warn('Could not get tile metrics:', e);
        }

        try {
            if (performance.memory) {
                const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                const memoryElement = document.getElementById('memory-usage-value');
                memoryElement.textContent = `${memoryMB}MB`;
                memoryElement.className = `metric-value ${memoryMB > 500 ? 'error' : memoryMB > 200 ? 'warning' : 'success'}`;
            } else {
                document.getElementById('memory-usage-value').textContent = 'N/A';
            }
        } catch (e) {
            document.getElementById('memory-usage-value').textContent = 'N/A';
        }

        try {
            let activeLayers = 0;
            if (currentStyle?.layers) {
                currentStyle.layers.forEach(layer => {
                    if (map.getLayer(layer.id)) {
                        const visibility = map.getLayoutProperty(layer.id, 'visibility');
                        if (visibility === 'visible') activeLayers++;
                    }
                });
            }
            const layersElement = document.getElementById('layers-active-value');
            layersElement.textContent = activeLayers;
            layersElement.className = `metric-value ${activeLayers > 50 ? 'warning' : 'success'}`;
        } catch (e) {
            document.getElementById('layers-active-value').textContent = 'N/A';
        }

        try {
            const zoom = map.getZoom();
            document.getElementById('zoom-level-value').textContent = zoom.toFixed(1);
        } catch (e) {
            document.getElementById('zoom-level-value').textContent = 'N/A';
        }
        updateTerrainIndicator();
    };

    const countFrame = () => {
        frameCount++;
        requestAnimationFrame(countFrame);
    };

    window.switchMode = switchMode;
    window.toggleBasemap = toggleBasemap;
    window.toggleHoverMode = toggleHoverMode;
    window.toggleAllFilters = () => filters?.toggleAllFilters();
    window.toggleAllLayers = toggleAllLayers;
    window.togglePerformancePanel = togglePerformancePanel;

    initializeMap();